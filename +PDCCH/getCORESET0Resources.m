function [N_RB, N_sym, RB_offset, mux_pattern] = getCORESET0Resources(...
    index, scs, min_channel_BW, k_SSB)
%GETCORESET0RESOURCES Returns CORESET0 resources parameters from TS 38.213 
%Section 13 Tables 13-1 to 13-10 corresponding to a row index INDEX (4 MSBs
%of PDCCHConfigSIB1 in MIB). The table is selected using the two-element
%vector SCS ([SSB,COMMON]), the minimum channel bandwidth MINCHANBW and SSB
%subcarrier offset KSSB.
% Inputs:
%   index           : a number representing the 4 MSBs of PDCCHConfigSIB1
%   in MIB
%   scs             : a number representing the subcarrier spacing in Hz
%   min_channel_BW  : a number representing the minimal available channel
%   bandwidth in Hz
%   k_SSB           : a number representing the kSSB
% Outputs:
%   N_RB            : a number representing the number of resource blocks
%   for CORESET0
%   N_sym           : a number representing the number of symbols for
%   CORESET0
%   RB_offset       : a number representing the resource block offset of
%   the CORESET0
%   mux_pattern     : a number representing the SSB and control resource
%   set multiplexing pattern

    % Frequency Range 1
    if all(scs == [15 15]*1e3)
        tab = [ 0   1   2   3   4   5   6   7   8   9  10  11  12  13  14   15;...
                1   1   1   1   1   1   1   1   1   1   1   1   1   1   1  NaN;...
               24  24  24  24  24  24  48  48  48  48  48  48  96  96  96  NaN;...
                2   2   2   3   3   3   1   1   2   2   3   3   1   2   3  NaN;...
                0   2   4   0   2   4  12  16  12  16  12  16  38  38  38  NaN];
    elseif all(scs == [15 30]*1e3)
        tab = [ 0   1   2   3   4   5   6   7   8   9  10  11  12  13  14   15;...
                1   1   1   1   1   1   1   1   1   1   1   1   1   1  NaN NaN;...
               24  24  24  24  24  24  24  24  48  48  48  48  48  48  NaN NaN;...
                2   2   2   2   3   3   3   3   1   1   2   2   3   3  NaN NaN;...
                5   6   7   8   5   6   7   8  18  20  18  20  18  20  NaN NaN];
    elseif all(scs == [30 15]*1e3)
        if any(min_channel_BW == [5,10]*1e6)
            tab = [ 0   1   2   3   4   5   6   7   8   9:15;...
                    1   1   1   1   1   1   1   1   1   NaN(1,7);...
                   48  48  48  48  48  48  96  96  96   NaN(1,7);...  
                    1   1   2   2   3   3   1   2   3   NaN(1,7);...  
                    2   6   2   6   2   6  28  28  28   NaN(1,7)];
        elseif min_channel_BW == 40*1e6
            tab = [ 0   1   2   3   4   5   6   7   8   9:15;...
                    1   1   1   1   1   1   1   1   1   NaN(1,7);...
                   48  48  48  96  96  96  96  96  96   NaN(1,7);...
                    1   2   3   1   1   2   2   3   3   NaN(1,7);...
                    4   4   4   0  56   0  56   0  56   NaN(1,7)];
        end
    elseif all(scs == [30 30]*1e3)
        if any(min_channel_BW == [5,10]*1e6)
            tab = [0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15;...
                   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1;...
                  24  24  24  24  24  24  24  24  24  24  48  48  48  48  48  48;...
                   2   2   2   2   2   3   3   3   3   3   1   1   1   2   2   2;...
                   0   1   2   3   4   0   1   2   3   4  12  14  16  12  14  16];
        elseif min_channel_BW == 40*1e6
            tab = [0   1   2   3   4   5   6   7   8   9  10:15;...
                   1   1   1   1   1   1   1   1   1   1  NaN(1,6);...
                  24  24  24  24  48  48  48  48  48  48  NaN(1,6);...
                   2   2   3   3   1   1   2   2   3   3  NaN(1,6);...
                   0   4   0   4   0  28   0  28   0  28  NaN(1,6)];
        end

    % Frequency Range 2
    elseif all(scs == [120 60]*1e3)
        tab = [ 0   1   2   3   4   5   6   7   8   9  10  11  12:15;...
                1   1   1   1   1   1   1   1   2   2   2   2  NaN(1,4);...
               48  48  48  48  48  48  96  96  48  48  96  96  NaN(1,4);...
                1   1   2   2   3   3   1   2   1   1   1   1  NaN(1,4);...
                0   8   0   8   0   8  28  28 -41  49 -41  97  NaN(1,4)];
        if k_SSB > 0
            idx = tab(1,:);
            tab(5,idx==8) = -42;
            tab(5,idx==10) = -42;
        end
    elseif all(scs == [120 120]*1e3)
        tab = [ 0   1   2   3   4   5   6   7  8:15;...
                1   1   1   1   3   3   3   3  NaN(1,8);...
               24  24  48  48  24  24  48  48  NaN(1,8);...
                2   2   1   2   2   2   2   2  NaN(1,8);...
                0   4  14  14 -20  24 -20  48  NaN(1,8)];
        if k_SSB > 0
          idx = tab(1,:);
          tab(5,idx==4) = -21;
          tab(5,idx==6) = -21;
        end
    elseif all(scs == [240 60]*1e3)
        tab = [0   1   2   3  4:15;...
               1   1   1   1  NaN(1,12);...
              96  96  96  96  NaN(1,12);...
               1   1   2   2  NaN(1,12);...
               0  16   0  16  NaN(1,12)];

    elseif all(scs == [240 120]*1e3)
        tab = [ 0   1   2   3   4   5   6   7  8:15;...
                1   1   1   1   2   2   2   2  NaN(1,8);...
               48  48  48  48  24  24  48  48  NaN(1,8);...
                1   1   2   2   1   1   1   1  NaN(1,8);...
                0   8   0   8 -41  25 -41  49  NaN(1,8)];
        if k_SSB > 0
            idx = tab(1,:);
            tab(5,idx==4) = -42;
            tab(5,idx==6) = -42;
        end
    else
        error('SSB block pattern and common subcarrier spacing combination not supported')
    end

    t = tab(:,index==tab(1,:));
    mux_pattern = t(2);
    N_RB = t(3);
    N_sym = t(4);
    RB_offset = t(5);
end